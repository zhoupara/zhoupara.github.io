<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>One</title>
  
  <subtitle>Only One</subtitle>
  <link href="http://www.paragarden,cn/atom.xml" rel="self"/>
  
  <link href="http://www.paragarden,cn/"/>
  <updated>2021-05-23T17:13:02.947Z</updated>
  <id>http://www.paragarden,cn/</id>
  
  <author>
    <name>para</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>成都分享会周末复盘</title>
    <link href="http://www.paragarden,cn/2021/05/24/0524/"/>
    <id>http://www.paragarden,cn/2021/05/24/0524/</id>
    <published>2021-05-23T16:45:20.000Z</published>
    <updated>2021-05-23T17:13:02.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="热点-–尊重生命-热爱生命"><a href="#热点-–尊重生命-热爱生命" class="headerlink" title="热点 –尊重生命 热爱生命"></a>热点 –尊重生命 热爱生命</h2><p>1.袁隆平先生 过世<br>2.甘肃越野赛 21人遇难</p><p>逝者已逝，我们能做到就是传承精神。<br>大的我可能还做不到，那我就不浪费一滴粮，节约爱惜每一滴粮。</p><p>越野赛事情<br>个人对事情的风险评估 很重要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">整件事 主要是恶劣天气突发，而大会没有强制要求运动员带相关安全保障的装备。到时运动员体温失衡而遇难。</span><br><span class="line">其实组织参加这些越野活动，认为是需要的，说的大一些，我们公民都要具备这种野外生存素质，来提高国民综合素质。</span><br><span class="line">而现状是，很多户外知识的普及不完全，很多民众对环境和不同地区的户外情况的不清楚。这是一条很漫长的路</span><br></pre></td></tr></table></figure><h2 id="参加-帅张成都线下大会"><a href="#参加-帅张成都线下大会" class="headerlink" title="参加 帅张成都线下大会"></a>参加 帅张成都线下大会</h2><p>一个月前，给自己定了这个计划，参加张哥成都线下大会。也终于等到了这天，过去的行程和回来的行程有些坎坷。但这不妨碍是一次对我自己的突破和成长。</p><a id="more"></a><h3 id="1-反思"><a href="#1-反思" class="headerlink" title="1.反思"></a>1.反思</h3><p>周五晚上，主要工作忙，没时间细细安排整个行程，倒是来回的行程出了差错。在等航班的时候，我深深的自己反思了。至于来回行程有多糟糕？成都线下大会，我简单列一下时间点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">周五:</span><br><span class="line">晚上10点 到重庆机场</span><br><span class="line"></span><br><span class="line">晚上11点 一个人到重庆市中心观音桥 吃夜宵</span><br><span class="line"></span><br><span class="line">凌晨12点 打车到重庆西站</span><br><span class="line"></span><br><span class="line">凌晨1点半 到酒店   ---&gt; 本来直接从机场打车到重庆西站就好</span><br><span class="line">周六：</span><br><span class="line">早上6点 酒店起床 </span><br><span class="line"></span><br><span class="line">6点50 赶火车 </span><br><span class="line"></span><br><span class="line">8点左右 重庆西站到成都东站</span><br><span class="line"></span><br><span class="line">近一个小时左右  地铁 赶到会场</span><br></pre></td></tr></table></figure><p>以上就是我坎坷的去路行程，这行程是我出发前被迫制定的…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">还有回来的行程</span><br><span class="line">预定的航班:  </span><br><span class="line">4点成都出发 到杭州 6点</span><br><span class="line"></span><br><span class="line">结果看错时间 以为是6点起飞 </span><br><span class="line"></span><br><span class="line">4点到机场的时候，完美错过</span><br><span class="line"></span><br><span class="line">原价定了晚上8点的航班 --&gt; 准备把这种车票裱起来</span><br><span class="line"></span><br><span class="line">关键航班还延误</span><br><span class="line"></span><br><span class="line">在机场等了五个小时</span><br></pre></td></tr></table></figure><p>自己的疏忽，损失的金钱和时间<br>这不可谓是一个深深的教训<br>遂，我给自己定下目标。每次出行前，把行程计划列完整再行动。<br>做事也是，工作也是。我就是脑子里有一个可行性的想法后，就直接迷迷糊糊按着感觉走了。往往中间会出很多的不确定，导致时间的拖延，各种损失。</p><p>以上是我对自己的行程反思，接下来讲讲这次大会我的收获～</p><h2 id="2-大会的分享"><a href="#2-大会的分享" class="headerlink" title="2.大会的分享"></a>2.大会的分享</h2><h3 id="1-社交"><a href="#1-社交" class="headerlink" title="(1)社交"></a>(1)社交</h3><p>主动走出去，积极去交流，遇见倾听不同的人。我还是有点腼腆，不过我想我走出了这一步，慢慢的尝试，就会突破腼腆</p><h3 id="2-把自己当创业者"><a href="#2-把自己当创业者" class="headerlink" title="(2)把自己当创业者"></a>(2)把自己当创业者</h3><p>“把自己当做创业者”，这是张哥提出的，这是一句很宏观的话。算是总体方针，具体的实施还是得按自己的情况去创业。我个人暂时理解的，对于我个人来说：职场技术能力，职场综合能力(时间管理，沟通表达，处理事务，与人协作等)，以及个人生活能力。<br>这些我都不足或欠缺，要花时间去尝试和学习，去补充。<br>以创业者的思维处理问题，道理很简单，如何去实施，按照自己的情况怎么去做。得自己专研。</p><h3 id="3-对自己狠一点-知道自己的痛点，想方设法去解决"><a href="#3-对自己狠一点-知道自己的痛点，想方设法去解决" class="headerlink" title="(3)对自己狠一点 知道自己的痛点，想方设法去解决"></a>(3)对自己狠一点 知道自己的痛点，想方设法去解决</h3><p>养成习惯，突破自我：张哥讲了他的经历。我觉得我能学习其精髓(赶飞机的事情)。知道自己的痛点，不惜一切去解决它。对就是这种和自己拼的精神，我是不具备的。<br>很多时候，我困了就睡，得过且过，很多事情觉得没有也行，觉得都在我的承受范围内，也不会强迫自己。一直想要周围的环境来压迫自己，没有逼自己的决心。是我自己的问题。总觉得没有时间，工作忙，每当自己写的差不多，做的差不多的时候就想，”OK，今天就到这里,明天再干吧。”<br>这就是缺少那种做好事情的决心。</p><h3 id="4-转变角度-以生产者，服务者看产品和事物"><a href="#4-转变角度-以生产者，服务者看产品和事物" class="headerlink" title="(4)转变角度 以生产者，服务者看产品和事物"></a>(4)转变角度 以生产者，服务者看产品和事物</h3><p>以创业者的角度看问题、看广告、去了解产品、去接触不同的事物。<br>了解商业背后逻辑，去挖掘数据。这是我要尝试去做的角度和方向，或者说是养成的习惯。这次大会后，我隐隐有自己的方向—创业。<br>创业九死一生，听起来就很不错。慢慢积累自己，等某一天恰好有了那机遇或者自己能力达到了，去满足自己这一颗想要不平凡的心。</p><h3 id="5-跨圈-与不同的思想沟通"><a href="#5-跨圈-与不同的思想沟通" class="headerlink" title="(5)跨圈 与不同的思想沟通"></a>(5)跨圈 与不同的思想沟通</h3><p>当然是我来说，最重要的是走出来。<br>相对于程序员封闭的圈子，跨圈交流，对不同人、行业的有新认知。张哥谈到，他做开发的时候，常常和产品，和运营混一起。每个人对事物有自己的角度，多交流，不同认知，海纳百川。</p><h3 id="6-面对不同的机会，如何做选择"><a href="#6-面对不同的机会，如何做选择" class="headerlink" title="(6)面对不同的机会，如何做选择"></a>(6)面对不同的机会，如何做选择</h3><p>说到如何做选择，我就是一个选择困难，遇到事情的时候，对事情判断的时候，总是想起特殊情况，倾向个例，独特。而张哥说，他相信概率，做选择的时候也是用概率的角度来做取舍。<br>细的去信，我那是感性，而概率是理性。</p><h3 id="7-对自己的要求"><a href="#7-对自己的要求" class="headerlink" title="(7)对自己的要求"></a>(7)对自己的要求</h3><p>后面问答会，提到，如何选择创业伙伴上？嘉宾提到一句话，有没有做过一件有结果的事？有结果的事可以是运营这几千粉丝的号，可以是组织办完一次优质的分享大会。我会想我自己，并没有。包括写的好物，也拿不出手。一个人做的有结果的事，我很认同。<br>接下来的阶段，我就是要专攻一个领域。做成一件有结果的事。</p><h3 id="8-个人情况："><a href="#8-个人情况：" class="headerlink" title="(8)个人情况："></a>(8)个人情况：</h3><p>1.如何安排好现在忙碌的工作时间和个人时间，是我接下来一个阶段要处理的</p><p>2.或许我对业务的熟悉，处理工作的效率会加快，还有改变我的时间管理方法，以及我的碰到事情问的态度。这都是我要去解决的。</p><p>3.接下来理想的上班状态，能轻松处理手头事务；有自己的时间，学习巩固技术。遇到好的点子，自己能出个工具去解决问题，有时间继续深耕好物，写写公众号~</p><p>The End<br>write by 2021/05/24 凌晨1点</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;热点-–尊重生命-热爱生命&quot;&gt;&lt;a href=&quot;#热点-–尊重生命-热爱生命&quot; class=&quot;headerlink&quot; title=&quot;热点 –尊重生命 热爱生命&quot;&gt;&lt;/a&gt;热点 –尊重生命 热爱生命&lt;/h2&gt;&lt;p&gt;1.袁隆平先生 过世&lt;br&gt;2.甘肃越野赛 21人遇难&lt;/p&gt;
&lt;p&gt;逝者已逝，我们能做到就是传承精神。&lt;br&gt;大的我可能还做不到，那我就不浪费一滴粮，节约爱惜每一滴粮。&lt;/p&gt;
&lt;p&gt;越野赛事情&lt;br&gt;个人对事情的风险评估 很重要&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;整件事 主要是恶劣天气突发，而大会没有强制要求运动员带相关安全保障的装备。到时运动员体温失衡而遇难。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;其实组织参加这些越野活动，认为是需要的，说的大一些，我们公民都要具备这种野外生存素质，来提高国民综合素质。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;而现状是，很多户外知识的普及不完全，很多民众对环境和不同地区的户外情况的不清楚。这是一条很漫长的路&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;参加-帅张成都线下大会&quot;&gt;&lt;a href=&quot;#参加-帅张成都线下大会&quot; class=&quot;headerlink&quot; title=&quot;参加 帅张成都线下大会&quot;&gt;&lt;/a&gt;参加 帅张成都线下大会&lt;/h2&gt;&lt;p&gt;一个月前，给自己定了这个计划，参加张哥成都线下大会。也终于等到了这天，过去的行程和回来的行程有些坎坷。但这不妨碍是一次对我自己的突破和成长。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>面试心得</title>
    <link href="http://www.paragarden,cn/2021/03/30/03-30/"/>
    <id>http://www.paragarden,cn/2021/03/30/03-30/</id>
    <published>2021-03-30T02:17:27.000Z</published>
    <updated>2021-03-30T05:43:14.594Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>ICMP协议</title>
    <link href="http://www.paragarden,cn/2021/02/19/2021-02-19/"/>
    <id>http://www.paragarden,cn/2021/02/19/2021-02-19/</id>
    <published>2021-02-19T09:37:50.000Z</published>
    <updated>2021-02-22T08:26:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h1><p>ICMP全称”Internet Control Message Protocol”,互联网控制报文协议。</p><a id="more"></a><h1 id="Wireshark抓包ping命令"><a href="#Wireshark抓包ping命令" class="headerlink" title="Wireshark抓包ping命令"></a>Wireshark抓包ping命令</h1><p>过滤规则： ip.addr == 47.114.0.16 and icmp<br>抓包内容： Ethernet II + IP + ICMP</p><p><img src="/images/2021-02-19/wireshark.png" alt="Lena"></p><h2 id="Ethernet-II"><a href="#Ethernet-II" class="headerlink" title="Ethernet II"></a>Ethernet II</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ethernet II： 源Mac地址(6字节) 目标mac地址(6字节) 类型(2字节)  共 14字节</span><br></pre></td></tr></table></figure><p><img src="/images/2021-02-19/mac%E5%B1%82.png" alt="Lena"></p><h2 id="IP报文头"><a href="#IP报文头" class="headerlink" title="IP报文头"></a>IP报文头</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IP: 版本(4位)/首部长度(4位) (1字节) 服务类型TOS(1字节) </span><br><span class="line">总长度(2字节)</span><br><span class="line">标识(2字节)</span><br><span class="line">标志(3位)/片偏移(13位) (2字节)</span><br><span class="line">TTL(1字节) 协议(1字节)</span><br><span class="line">首部校验和(2字节)</span><br><span class="line">源IP地址(4字节)</span><br><span class="line">目标IP地址(4字节)  共 20字节</span><br></pre></td></tr></table></figure><h2 id="ICMP报文"><a href="#ICMP报文" class="headerlink" title="ICMP报文"></a>ICMP报文</h2><p><img src="/images/2021-02-19/ip%E6%8A%A5%E6%96%87%E5%A4%B4.png" alt="Lena"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ICMP：类型(1字节) 代码(1字节)</span><br><span class="line"> 校验和(2字节)</span><br><span class="line"> 根据类型和代码不同而不同</span><br></pre></td></tr></table></figure><p><img src="/images/2021-02-19/ICMP%E6%8A%A5%E6%96%87.png" alt="Lena"></p><h1 id="ICMP报文的格式"><a href="#ICMP报文的格式" class="headerlink" title="ICMP报文的格式"></a>ICMP报文的格式</h1><p>ICMP报文是封装在IP包里面的，属于网络层。<br><img src="/images/2021-02-19/ICMP%E6%A0%BC%E5%BC%8F.jpg" alt="Lena"></p><h1 id="查询报文类型"><a href="#查询报文类型" class="headerlink" title="查询报文类型"></a>查询报文类型</h1><p>查询报文类型 用于诊断的查询信息.</p><p>类型                代码        状态        描述<br>0 - Echo Reply    0                echo响应 (被程序ping使用）<br>8 - 请求回显        0                Echo请求<br>9 - 路由器通告    0                路由通告<br>10 - 路由器请求    0                路由器的发现/选择/请求<br>13 - 时间戳请求    0                时间戳请求<br>14 - 时间戳应答    0                时间戳应答<br>常见的类型是主动请求为8，主动请求的应答为0</p><h1 id="差错报文类型"><a href="#差错报文类型" class="headerlink" title="差错报文类型"></a>差错报文类型</h1><p>差错报文类型 通知出错原因的错误消息<br>类型 1.2 未分配 保留</p><h2 id="3-目的不可达"><a href="#3-目的不可达" class="headerlink" title="3-目的不可达"></a>3-目的不可达</h2><p>代码 0        目标网络不可达<br>代码 1        目标主机不可达<br>代码 2        目标协议不可达<br>代码 3        目标端口不可达<br>代码 4        要求分段并设置DF flag标志        </p><h2 id="5-重定向"><a href="#5-重定向" class="headerlink" title="5-重定向"></a>5-重定向</h2><p>代码 0        重定向网络<br>代码 1        重定向主机<br>代码 2        基于TOS 的网络重定向<br>代码 3        基于TOS 的主机重定向</p><h2 id="11-ICMP超时"><a href="#11-ICMP超时" class="headerlink" title="11-ICMP超时"></a>11-ICMP超时</h2><p>代码 0        TTL 超时<br>代码 1         分片重组超时</p><h1 id="查询报文应用-ping命令"><a href="#查询报文应用-ping命令" class="headerlink" title="查询报文应用: ping命令"></a>查询报文应用: ping命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ping -c 2 www.padparadccha.cn</span><br><span class="line"></span><br><span class="line">-c 2 收到两次包后，自动退出</span><br><span class="line">-i 3 发送周期 3秒</span><br><span class="line">-s 1024 设置发送包的大小</span><br><span class="line">-t 255 设置TTL值为 255</span><br></pre></td></tr></table></figure><p><img src="/images/2021-02-19/ping.png" alt="Lena"></p><h1 id="差错报文应用-Traceroute命令"><a href="#差错报文应用-Traceroute命令" class="headerlink" title="差错报文应用: Traceroute命令"></a>差错报文应用: Traceroute命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute www.padparadccha.cn 显示到达目的地的数据包路由</span><br></pre></td></tr></table></figure><p>Traceroute程序的设计是利用ICMP及IP header的TTL（Time To Live）栏位（field）</p><blockquote><p>TTL是1的IP datagram（其实，每次送出的为3个40字节的包，包括源地址，目的地址和包发出的时间标签）到目的地，当路径上的第一个路由器（router）收到这个datagram时，它将TTL减1。此时，TTL变为0了，所以该路由器会将此datagram丢掉，并送回一个「ICMP time exceeded」消息（包括发IP包的源地址，IP包的所有内容及路由器的IP地址），traceroute 收到这个消息后，便知道这个路由器存在于这个路径上，接着traceroute 再送出另一个TTL是2 的datagram，发现第2 个路由器…… traceroute 每次将送出的datagram的TTL 加1来发现另一个路由器，这个重复的动作一直持续到某个datagram 抵达目的地。</p></blockquote><blockquote><p>当datagram到达目的地后，该主机并不会送回ICMP time exceeded消息，因为它已是目的地了，那么traceroute如何得知目的地到达了呢？Traceroute在送出UDP datagrams到目的地时，它所选择送达的port number 是一个一般应用程序都不会用的号码（30000 以上），所以当此UDP datagram 到达目的地后该主机会送回一个「ICMP port unreachable」的消息，而当traceroute 收到这个消息时，便知道目的地已经到达了。所以traceroute 在Server端也是没有所谓的Daemon 程式。</p></blockquote><h2 id="Traceroute规则"><a href="#Traceroute规则" class="headerlink" title="Traceroute规则"></a>Traceroute规则</h2><p>1.故意设置特殊的TTL，来追踪去往目的地时沿途经过的路由器<br>2.故意设置不分片，从而确定路径的MTU</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ICMP协议&quot;&gt;&lt;a href=&quot;#ICMP协议&quot; class=&quot;headerlink&quot; title=&quot;ICMP协议&quot;&gt;&lt;/a&gt;ICMP协议&lt;/h1&gt;&lt;p&gt;ICMP全称”Internet Control Message Protocol”,互联网控制报文协议。&lt;/p&gt;</summary>
    
    
    
    
    <category term="网络" scheme="http://www.paragarden,cn/tags/网络/"/>
    
  </entry>
  
  <entry>
    <title>makefile制作静态库和动态库</title>
    <link href="http://www.paragarden,cn/2021/01/11/2021-01-11/"/>
    <id>http://www.paragarden,cn/2021/01/11/2021-01-11/</id>
    <published>2021-01-11T11:16:42.000Z</published>
    <updated>2021-01-12T00:48:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>makefile的基本以及动态库和静态库的基本自行百度<br>本文主要将如何用makefile制作动态库和静态库以及使用</p><a id="more"></a><h1 id="main-c-add-c-add-h-文件"><a href="#main-c-add-c-add-h-文件" class="headerlink" title="main.c  add.c  add.h 文件"></a>main.c  add.c  add.h 文件</h1><h2 id="三个文件"><a href="#三个文件" class="headerlink" title="三个文件"></a>三个文件</h2><p><img src="/images/2021-01-11/add_c.png" alt="Lena"><br><img src="/images/2021-01-11/add_h.png" alt="Lena"><br><img src="/images/2021-01-11/main_c.png" alt="Lena"></p><h2 id="文件存放目录结构"><a href="#文件存放目录结构" class="headerlink" title="文件存放目录结构"></a>文件存放目录结构</h2><p><img src="/images/2021-01-11/tree.png" alt="Lena"></p><h1 id="静态库文件"><a href="#静态库文件" class="headerlink" title="静态库文件"></a>静态库文件</h1><h2 id="静态库文件的制作"><a href="#静态库文件的制作" class="headerlink" title="静态库文件的制作"></a>静态库文件的制作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">制作.o文件</span><br><span class="line">gcc -c *.c</span><br><span class="line">用ar打包生成.a静态库文件</span><br><span class="line">ar cr 静态库的名字(libMytest.a) 生成的所有的.o</span><br></pre></td></tr></table></figure><p><img src="/images/2021-01-11/a.png" alt="Lena"></p><h2 id="静态库文件的调用"><a href="#静态库文件的调用" class="headerlink" title="静态库文件的调用"></a>静态库文件的调用</h2><p>1.gcc main.c lib/libadd.a -I include -o main<br>2.gcc main.c -I include -L lib -l add -o main<br>nm libadd.a<br><img src="/images/2021-01-11/make_a.png" alt="Lena"></p><h1 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h1><h2 id="动态库文件的制作"><a href="#动态库文件的制作" class="headerlink" title="动态库文件的制作"></a>动态库文件的制作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">生成与位置无关的.o文件</span><br><span class="line">  gcc -fPIC -c *.c</span><br><span class="line">生成.so动态库文件</span><br><span class="line">  gcc -shared -I include -o lib库名.so *.o</span><br></pre></td></tr></table></figure><p><img src="/images/2021-01-11/so.png" alt="Lena"></p><h2 id="动态库文件的调用"><a href="#动态库文件的调用" class="headerlink" title="动态库文件的调用"></a>动态库文件的调用</h2><p>1.gcc main.c lib/libMyCalc.so -I include -o app 可以直接加绝对路径编译<br>2.gcc main.c -I include -L lib -l MyCalc -o app 需要更新环境变量<br>ldd<br><img src="/images/2021-01-11/make_so.png" alt="Lena"></p><p>注： 第二种需要配置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LD_LIBRARY_PATH</span><br><span class="line">export LD_LIBRARY_PATH=./lib</span><br><span class="line">vi ~/.bashrc</span><br><span class="line">export LD_LIBRARY_PATH=/home/lib</span><br><span class="line"></span><br><span class="line">1.找到动态库链接器的配置文件 vi /etc/ld.so.conf</span><br><span class="line">2.动态库的路径写到配置文件中</span><br><span class="line">3.更新 sudo ldconfig -v</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;makefile的基本以及动态库和静态库的基本自行百度&lt;br&gt;本文主要将如何用makefile制作动态库和静态库以及使用&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>hexo博客 + nginx + https-ssl</title>
    <link href="http://www.paragarden,cn/2020/11/13/2020-11-13/"/>
    <id>http://www.paragarden,cn/2020/11/13/2020-11-13/</id>
    <published>2020-11-13T07:28:57.000Z</published>
    <updated>2020-11-13T09:02:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>紧接上篇文章，想在个人博客上添加ssl证书，能够https访问个人网站。</p><a id="more"></a><h1 id="下载申请免费ssl证书"><a href="#下载申请免费ssl证书" class="headerlink" title="下载申请免费ssl证书"></a>下载申请免费ssl证书</h1><p>1.免费购买证书<br><img src="/images/2020_11_13_pic00.png" alt="Lena"><br><img src="/images/2020_11_13_pic01.png" alt="Lena"><br><img src="/images/2020_11_13_pic02.png" alt="Lena"><br>2.证书申请<br><img src="/images/2020_11_13_pic03.png" alt="Lena"><br>3.配置到域名解析列表<br>在域名dns中添加txt信息<br>4.证书验证<br>5.证书部署<br>6.证书下载<br>下载生成 证书文件 和 私钥文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@para1 www]# ls 4757052_www.padparadccha.cn.*</span><br><span class="line">4757052_www.padparadccha.cn.key  4757052_www.padparadccha.cn.pem</span><br></pre></td></tr></table></figure><h1 id="nginx-更新-http-ssl-模块"><a href="#nginx-更新-http-ssl-模块" class="headerlink" title="nginx 更新 http_ssl 模块"></a>nginx 更新 http_ssl 模块</h1><p>1.查看nginx是否安装http_ssl_module模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/local/nginx/sbin/nginx -V</span><br></pre></td></tr></table></figure><p>如果出现 configure arguments: –with-http_ssl_module, 则已安装（下面的步骤可以跳过，进入 nginx.conf 配置）。<br>2.需要新安装的模块，重新编译<br>下载添加 ngx_http_google_filter_module</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/cuber/ngx_http_google_filter_module</span><br></pre></td></tr></table></figure><p>下载添加 ngx_http_substitutions_filter_module</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/yaoweibin/ngx_http_substitutions_filter_module</span><br></pre></td></tr></table></figure><p>3.安装 编译新的nginx<br>进入nginx的源文件目录 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@para1 nginx]# sbin/nginx -V</span><br><span class="line">nginx version: nginx/1.18.0</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC) </span><br><span class="line">built with OpenSSL 1.1.1g  21 Apr 2020</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/usr/local/nginx --with-http_gzip_static_module --http-client-body-temp-path=/usr/local/nginx/tmp/client/ --http-proxy-temp-path=/usr/local/nginx/tmp/proxy/ --http-fastcgi-temp-path=/usr/local/nginx/tmp/fcgi/ --with-poll_module --with-file-aio --with-http_realip_module --with-http_addition_module --with-http_addition_module --with-http_random_index_module --with-http_stub_status_module --http-uwsgi-temp-path=/usr/local/nginx/uwsgi_temp --http-scgi-temp-path=/usr/local/nginx/scgi_temp --with-stream</span><br></pre></td></tr></table></figure><p>添加新的–with-http_ssl_module模块和配置两个add-module路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx --with-openssl=/usr/local/openssl --with-http_ssl_module --with-http_gzip_static_module --http-client-body-temp-path=/usr/local/nginx/tmp/client/ --http-proxy-temp-path=/usr/local/nginx/tmp/proxy/ --http-fastcgi-temp-path=/usr/local/nginx/tmp/fcgi/ --with-poll_module --with-file-aio --with-http_realip_module --with-http_addition_module --with-http_addition_module --with-http_random_index_module --with-http_stub_status_module --http-uwsgi-temp-path=/usr/local/nginx/uwsgi_temp --http-scgi-temp-path=/usr/local/nginx/scgi_temp --with-stream --add-module=/root/data/ngx_http_google_filter_module --add-module=/root/data/ngx_http_substitutions_filter_module</span><br></pre></td></tr></table></figure><p>4.make 注:千万不要make install 那样就会覆盖安装<br>5.将原来的 Nginx备份，拷贝新生成的nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak</span><br><span class="line">cp objs/nginx /usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><h1 id="nginx-配置文件"><a href="#nginx-配置文件" class="headerlink" title="nginx 配置文件"></a>nginx 配置文件</h1><p>修改 nginx.conf 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.padparadccha.cn;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /home/git/project/blog;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       443 ssl;</span><br><span class="line">        server_name  www.padparadccha.cn;</span><br><span class="line"></span><br><span class="line">        ssl_certificate      cert.pem;</span><br><span class="line">        ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">        ssl_session_cache    shared:SSL:1m;</span><br><span class="line">        ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">        ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">        ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /home/git/project/blog;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   [...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>listen    ssl访问端口号为 443<br>ssl_certificate 证书文件<br>ssl_certificate_key 私钥文件<br>ssl_ciphers  配置加密套件，写法遵循openssl标准</p><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>/usr/local/nginx/sbin/nginx</p><h1 id="关于https的文章"><a href="#关于https的文章" class="headerlink" title="关于https的文章"></a>关于https的文章</h1><p><a href="https://www.cnblogs.com/zery/p/5164795.html" target="_blank" rel="noopener">https://www.cnblogs.com/zery/p/5164795.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;紧接上篇文章，想在个人博客上添加ssl证书，能够https访问个人网站。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>hexo博客部署到服务器</title>
    <link href="http://www.paragarden,cn/2020/11/12/2020-11-12/"/>
    <id>http://www.paragarden,cn/2020/11/12/2020-11-12/</id>
    <published>2020-11-12T06:01:38.000Z</published>
    <updated>2020-11-12T06:57:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前博客都是放在github page上进行部署，现在用nginx部署在自己的服务器上<br>前面的基本配置，简单略过，详细可以参考hexo官方文档<br>本篇主要在服务器建立一个裸仓库，本地将静态页面上传到服务器，用nginx进行部署</p><a id="more"></a><h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><h2 id="本地安装-node"><a href="#本地安装-node" class="headerlink" title="本地安装 node"></a>本地安装 node</h2><p>1.node官网下载 推荐使用nvm<br>2.配置全局变量<br>3.安装hexo-cli</p><h2 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h2><p>1.初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init myblo &amp;&amp; myblog</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure><p>2.下载主题<br>git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next<br>3.本地执行hexo项目 npm start<br>添加 start脚本<br><img src="/images/pic01.png" alt="Lena"><br>4.验证效果</p><h2 id="git环境搭建"><a href="#git环境搭建" class="headerlink" title="git环境搭建"></a>git环境搭建</h2><p>1.git 安装<br>2.ssh 认证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email youremail@example.com</span><br><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br><span class="line">git config --global core.autocrlf false  // 禁用自动转换，这个不设置后面上传时会出现警告，如下</span><br></pre></td></tr></table></figure><h1 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h1><h2 id="搭建远程Git私库"><a href="#搭建远程Git私库" class="headerlink" title="搭建远程Git私库"></a>搭建远程Git私库</h2><p>1.登录远程服务器<br>2.安装git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git --version // 如无，则安装</span><br><span class="line">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel</span><br><span class="line">yum install -y git</span><br></pre></td></tr></table></figure><p>3.创建用户并配置其仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">useradd git</span><br><span class="line">passwd git // 设置密码</span><br><span class="line">su git // 这步很重要，不切换用户后面会很麻烦</span><br><span class="line">cd /home/git/</span><br><span class="line">mkdir -p projects/blog // 项目存在的真实目录</span><br><span class="line">mkdir repos &amp;&amp; cd repos</span><br><span class="line">git init --bare blog.git // 创建一个裸露的仓库</span><br><span class="line">cd blog.git/hooks</span><br><span class="line">vi post-receive // 创建 hook 钩子函数，输入了内容如下</span><br><span class="line">#输入完成后</span><br><span class="line">chmod +x post-receive</span><br><span class="line">exit // 退出到 root 登录</span><br><span class="line">chown -R git:git /home/git/repos/blog.git // 添加权限</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file  post-receive:</span><br><span class="line">#!/bin/sh</span><br><span class="line">git --work-tree=/home/git/projects/blog --git-dir=/home/git/repos/blog.git checkout -f</span><br><span class="line">#将传到/home/git/repos/blog.git地址的文件，放到/home/git/projects/blog</span><br></pre></td></tr></table></figure><p>4.测试git仓库是否可用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@server_ip:/home/git/repos/blog.git</span><br></pre></td></tr></table></figure><p>5.本地电脑 建立ssh信任关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i C:/Users/yourname/.ssh/id_rsa.pub git@server_ip</span><br><span class="line">ssh git@server_ip // 测试能否登录</span><br></pre></td></tr></table></figure><p>6.禁用git用户的shell登录权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells // 查看 git-shell 是否在登录方式里面</span><br><span class="line">which git-shell // 查看是否安装</span><br><span class="line">vi /etc/shells</span><br><span class="line">#添加上2步显示出来的路径，通常在 /usr/bin/git-shell</span><br></pre></td></tr></table></figure><p>修改/etc/passwd中的权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 将原来的</span><br><span class="line">git:x:1000:1000::/home/git:/bin/bash</span><br><span class="line"></span><br><span class="line">// 修改为</span><br><span class="line">git:x:1000:1000:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure><h1 id="搭建nginx服务器"><a href="#搭建nginx服务器" class="headerlink" title="搭建nginx服务器"></a>搭建nginx服务器</h1><h2 id="下载安装-nginx"><a href="#下载安装-nginx" class="headerlink" title="下载安装 nginx"></a>下载安装 nginx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">wget http://nginx.org/download/nginx-1.15.2.tar.gz</span><br><span class="line">tar xzvf nginx-1.15.2.tar.gz</span><br><span class="line">cd nginx-1.15.2</span><br><span class="line">./configure // 如果后面还想要配置 SSL 协议，就执行后面一句！</span><br><span class="line">./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_module</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">alias nginx=&apos;/usr/local/nginx/sbin/nginx&apos; // 为 nginx 取别名，后面可直接用</span><br></pre></td></tr></table></figure><h2 id="配置nginx文件"><a href="#配置nginx文件" class="headerlink" title="配置nginx文件"></a>配置nginx文件</h2><p>1.先启动是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx </span><br><span class="line">#浏览器查看 server_ip，默认是 80 端口</span><br></pre></td></tr></table></figure><p>2.修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop // 先停止nginx</span><br><span class="line">cd /usr/local/nginx/conf</span><br><span class="line">vi nginx.conf</span><br><span class="line">修改 root 解析路径, 如下图</span><br><span class="line">同时将 user 改为 root, 不然nginx无法访问 /home/git/projects/blog</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><p><img src="/images/2020_11_12_pic02.png" alt="Lena"></p><h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><h2 id="本地配置-config-yml文件"><a href="#本地配置-config-yml文件" class="headerlink" title="本地配置 _config.yml文件"></a>本地配置 _config.yml文件</h2><p><img src="/images/2020_11_12_pic03.png" alt="Lena"></p><h2 id="在package-json-中添加npm脚本"><a href="#在package-json-中添加npm脚本" class="headerlink" title="在package.json 中添加npm脚本"></a>在package.json 中添加npm脚本</h2><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>本地调试 npm start<br>上次服务器 npm run deply</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前博客都是放在github page上进行部署，现在用nginx部署在自己的服务器上&lt;br&gt;前面的基本配置，简单略过，详细可以参考hexo官方文档&lt;br&gt;本篇主要在服务器建立一个裸仓库，本地将静态页面上传到服务器，用nginx进行部署&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>文件IO--fileIO</title>
    <link href="http://www.paragarden,cn/2020/10/12/fileIO/"/>
    <id>http://www.paragarden,cn/2020/10/12/fileIO/</id>
    <published>2020-10-12T02:58:48.000Z</published>
    <updated>2020-10-12T07:53:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件IO简介"><a href="#文件IO简介" class="headerlink" title="文件IO简介"></a>文件IO简介</h1><p>1.文件IO也称不带缓冲的I/O(unbuffered)。不带缓冲指的是每个read, write都调用内核中的一个系统调用。<br>2.遵循POSIX相关标准，任何兼容POSIX标准的操作系统上都支持文件I/O。<br>3.读写文件时, 每次操作都会执行相关系统调用, 好处是直接读写实际文件，坏处是频繁的系统调用会增加系统开销。</p><a id="more"></a><h1 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h1><p>–&gt; 打开文件 + 移动到末尾<br>考虑一个进程，它将数据添加到一个文件尾端。早期的 unix版本并不支持open的O_APPEND选项，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (lseek(fd, 0L, 2) &lt; 0)</span><br><span class="line">err_sys(&quot;lseek error&quot;);</span><br><span class="line">if (write(fd, buff, 100) != 100)</span><br><span class="line">err_sys(&quot;write error&quot;);</span><br></pre></td></tr></table></figure><p>以上情况，若两个进程A和B对同一文件进行添加操作。每个进程都打开了该文件，但未使用O_APPEND标志。<br>每个进程都有它自己的文件表项，但是共享一个v节点表项。<br>1.假定进程A调用lseek，对于进程A的该文件的当前位置量设置为1500L,<br>2.然后内核切换进程使B进程运行。进程B执行lseek，也将该文件的当前位移量设置为1500L,<br>3.然后B调用write，它将B的该文件的当前位置量增至1600<br>4.因为文件的长度已经增加，所以内核对v节点中的当前长度更新为1600<br>5.然后内核又切换使用进程A恢复运行<br>6.当A调用write时，及从其当前文件位移量(1500)处写数据到文件中<br>这样就覆盖了进程B写到文件中的内容</p><p>这里的问题出在逻辑操作”定位到文件尾处，然后写”使用了两个分开的函数调用。<br>解决的方法是使用这两个操作对于进程而言成为一个原子操作。<br>unix提供了一种方法使这种操作成为原子操作，在打开文件时设置O_APPEND标志。<br>使内核每次对这种文件进行写之前，都将进程的当前位置量设置到该文件的尾端处，<br>于是在每次写之前就不再需要调用lseek</p><p>–&gt; 创建临时文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">char *tmpnam(char *s);</span><br><span class="line">描述 create a name for a temporary file</span><br><span class="line"></span><br><span class="line">FILE *tmpfile(void);</span><br><span class="line">描述 create a temporary file</span><br></pre></td></tr></table></figure><p>以上两个函数都是创建一个临时文件。<br>tmpnam函数 得到一个临时文件名之后需要自己创建文件并打开<br>tmpfile函数 得到并打开一个临时文件(w+), 文件会自动删除当它关闭或者进程结束<br>对比两个函数，tmpfile函数操作原子化。</p><h1 id="重定向-dup、dup2"><a href="#重定向-dup、dup2" class="headerlink" title="重定向 dup、dup2"></a>重定向 dup、dup2</h1><h2 id="函数-dup、dup2"><a href="#函数-dup、dup2" class="headerlink" title="函数 dup、dup2"></a>函数 dup、dup2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int dup(int oldfd);  //uses the lowest-numbered unused descriptor for the new descriptor</span><br><span class="line">int dup2(int oldfd, int newfd);  //makes newfd be the copy of oldfd, closing newfd first if necessary</span><br><span class="line"></span><br><span class="line">//关闭 newfd前，注意：</span><br><span class="line">//1.oldfd 是一个无效的文件描述符 调用失败,newfd不会关闭</span><br><span class="line">//2.oldfd 是一个有效的文件描述符 且newfd和oldfd值一样，dup2什么也不做，直接返回newfd</span><br><span class="line">返回值 </span><br><span class="line">On success, these system calls return the new descriptor.  On error, -1 is returned, and errno is set appropriately.</span><br></pre></td></tr></table></figure><h2 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h2><p>1.命令 &lt; 文件   将指定文件作为命令的输入设备<br>2.命令  &lt;&lt; 分界符 表示从标准输入设备（键盘）中读入，直到遇到分界符才停止（读入的数据不包括分界符），这里的分界符其实就是自定义的字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">命令 &lt; 文件 </span><br><span class="line">1.fd_file = open  O_RDONLY | O_EXCL </span><br><span class="line">2.fd_in = dup(0)</span><br><span class="line">3.dup2(fd_file, 0)</span><br><span class="line">操作</span><br><span class="line">4.dup2(fd_in, 0)</span><br><span class="line">5.close(fd_in)</span><br><span class="line">6.close(fd_file)</span><br></pre></td></tr></table></figure><h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><p>1.命令 &gt; 文件<br>3.命令 2&gt; 文件  错误重定向 至文件<br>3.命令 &gt;&gt; 文件<br>4.命令  2&gt;&gt; 文件<br>5.命令 &gt;&gt; 文件 2&gt;&amp;1  // 命令 &amp;&gt;&gt; 文件  // &amp;&gt;/dev/null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">command &gt; file  输出重定向 至file,以覆盖的方式</span><br><span class="line">1.fd_file = open 有则清空无则创建 O_WRONLY | O_CREAT | O_TRUNC</span><br><span class="line">2.fd_out = dup(1)</span><br><span class="line">3.dup2(fd_file,1)</span><br><span class="line">4.操作</span><br><span class="line">5.dup2(fd_out,1)</span><br><span class="line">6.close(fd_out)</span><br><span class="line">7.close(fd_file)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">command &gt;&gt;file 输出重定向 至file,以追加的方式 </span><br><span class="line">1.fd_file = open 有则清空无则创建 O_WRONLY | O_CREAT | O_APPEND</span><br><span class="line">2.fd_out = dup(1)  //复制标准输出 进行备份</span><br><span class="line">3.dup2(fd_file,1)  //将标准输出的位置进行替换  </span><br><span class="line">4.操作</span><br><span class="line">5.dup2(fd_out,1)   //标准输出进行还原</span><br><span class="line">6.close(fd_out)</span><br><span class="line">7.close(fd_file)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">命令 &gt;&gt; 文件 2&gt;&amp;1  以追加的方式，把正确输出和错误信息同时保存到同一个文件（file）中。</span><br><span class="line">1.fd_file = open 有则清空无则创建 O_WRONLY | O_CREAT | O_APPEND</span><br><span class="line">2.fd_out = dup(1)   fd_err = dup(2) //复制标准输出 进行备份</span><br><span class="line">3.dup2(fd_file,1)   dup2(fd_file,2) //将标准输出的位置进行替换</span><br><span class="line">4.操作</span><br><span class="line">5.dup2(fd_out,1)  dup2(fd_err,2) //标准输出进行还原</span><br><span class="line">6.close(fd_out) close(fd_err)</span><br><span class="line">7.close(fd_file)</span><br></pre></td></tr></table></figure><p>注意<br>1.dup使用的是系统调用IO，如果替换标准输入输出，而使用文件IO的话，会有缓冲区的问题<br>2.dup使用的时候，注意原子操作，其他人会操作文件描述符</p><h2 id="命令-gt-gt-文件-2-gt-amp-1-的由来"><a href="#命令-gt-gt-文件-2-gt-amp-1-的由来" class="headerlink" title="命令 &gt;&gt; 文件 2&gt;&amp;1 的由来"></a>命令 &gt;&gt; 文件 2&gt;&amp;1 的由来</h2><p>命令 1&gt;&gt; 文件 2&gt;&amp;1   —&gt;  2&gt;&amp;1   用文件描述符1修改文件描述符2，因此文件描述符2(错误输出)dup2(1,2) –&gt; 错误输出和标准输出都输出至 文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[para dup]$ ls -l aaa &amp;&gt; file       &amp;&gt;  全部输出 至file</span><br><span class="line">[para dup]$ ls -l aaa &gt;&gt; file 2&gt;&amp;1    先标准输出 输出至file 将1复制给1，共同输出至file</span><br></pre></td></tr></table></figure><h2 id="内容输出至-dev-null"><a href="#内容输出至-dev-null" class="headerlink" title="内容输出至 /dev/null"></a>内容输出至 /dev/null</h2><p>命令 &gt;&gt; /dev/null 2&gt;&amp;1<br>命令 &amp;&gt;&gt; /dev/null</p><p><img src="/images/fileIO01.png" alt="Lena"></p><h1 id="文件和设备"><a href="#文件和设备" class="headerlink" title="文件和设备"></a>文件和设备</h1><pre><code>--&gt; /dev/console - 系统控制台,系统错误信息都输出到这里--&gt; /dev/tty - 进程控制台，访问不同的物理设备。--&gt; /dev/null - 空设备，向所有写这个设备的输出都将被丢弃--&gt; /dev/zero </code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;文件IO简介&quot;&gt;&lt;a href=&quot;#文件IO简介&quot; class=&quot;headerlink&quot; title=&quot;文件IO简介&quot;&gt;&lt;/a&gt;文件IO简介&lt;/h1&gt;&lt;p&gt;1.文件IO也称不带缓冲的I/O(unbuffered)。不带缓冲指的是每个read, write都调用内核中的一个系统调用。&lt;br&gt;2.遵循POSIX相关标准，任何兼容POSIX标准的操作系统上都支持文件I/O。&lt;br&gt;3.读写文件时, 每次操作都会执行相关系统调用, 好处是直接读写实际文件，坏处是频繁的系统调用会增加系统开销。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>标准IO--stdIO</title>
    <link href="http://www.paragarden,cn/2020/10/12/stdIO/"/>
    <id>http://www.paragarden,cn/2020/10/12/stdIO/</id>
    <published>2020-10-12T02:51:14.000Z</published>
    <updated>2020-10-12T07:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标准IO简介"><a href="#标准IO简介" class="headerlink" title="标准IO简介"></a>标准IO简介</h1><p>1.标准I/O是ANSI C建立的一个标准I/O模型, 是一个标准函数包和stdio.h头文件中的定义, 不依赖系统内核, 所以移植性强。<br>2.遵循ANSI C相关标准。需要开发环境中有标准I/O库, 标准I/O就可以使用。<br>3.在文件IO的基础上封装文件描述符并维护了缓冲机制。<br>4.fopen函数 打开一个文件, 并且建立了一个流缓冲(用户空间，读写模式下建立两个缓冲区), 还创建了一个包含文件和缓冲区相关信息的FILE结构体, 从而先读写缓冲区, 必要时候再访问实际文件。</p><a id="more"></a><p>注：<br>（Linux 中使用的是glibc, 它是标准C库的超集。不仅包含ANSI C中定义的函数, 还包括POSIX标准中定义的函数。因此, Linux 下既可以使用标准I/O, 也可以使用文件I/O）</p><h1 id="标准IO的格式化"><a href="#标准IO的格式化" class="headerlink" title="标准IO的格式化"></a>标准IO的格式化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">--标准输出</span><br><span class="line">int printf(const char *format, ...);--&gt;标准输出</span><br><span class="line">int fprintf(FILE *stream, const char *format, ...);  --&gt; 指定的流</span><br><span class="line">int sprintf(char *str, const char *format, ...);--&gt; 指定str(缓冲区)</span><br><span class="line"></span><br><span class="line">--标准输出</span><br><span class="line">int scanf(const char *format, ...);</span><br><span class="line">int fscanf(FILE *stream, const char *format, ...);</span><br><span class="line">int sscanf(const char *str, const char *format, ...);</span><br></pre></td></tr></table></figure><p>格式字符串的一般形式：<br>[标志][输出最小宽度][.精度][长度]类型<br>其中方括号[]为可选项</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>类型字符用以表示输出数据的类型<br>格式字符    意义<br>d        以十进制形式输出带符号整数(正数不输出符号)<br>o        以八进制形式输出无符号整数(不输出前缀0)<br>x,X        以十六进制形式输出无符号整数(不输出前缀Ox)<br>u        以十进制形式输出无符号整数<br>f        以小数形式输出单、双精度实数<br>e,E        以指数形式输出单、双精度实数<br>g,G        以%f或%e中较短的输出宽度输出单、双精度实数<br>c        输出单个字符<br>s        输出字符串</p><h2 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h2><p>标志字符为’-‘、’+’、’#’和空格<br>标志     意义<br>‘-‘        结果左对齐，右边填空格<br>‘+’        输出符号(正号或负号)<br>空格        输出值为正时冠以空格，为负时冠以负号<br>‘#’        对c、s、d、u类无影响；<br>        对o类，在输出时加前缀o；<br>        对x类，在输出时加前缀0x；<br>        对e、g、f 类当结果有小数时才给出小数点。</p><h2 id="输出最小宽度"><a href="#输出最小宽度" class="headerlink" title="输出最小宽度"></a>输出最小宽度</h2><p>用十进制整数来表示输出的最少位数。若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。</p><h2 id="精度"><a href="#精度" class="headerlink" title="精度"></a>精度</h2><p>精度格式符以“.”开头，后跟十进制整数。本项的意义是：如果输出数字，则表示小数的位数；如果输出的是字符，则表示输出字符的个数；若实际位数大于所定义的精度数，则截去超过的部分。</p><h2 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h2><p>长度格式符为h、l两种，h表示按短整型量输出，l表示按长整型量输出。</p><h1 id="行缓冲和全缓冲-fflush-–-gt-面试题"><a href="#行缓冲和全缓冲-fflush-–-gt-面试题" class="headerlink" title="行缓冲和全缓冲(fflush) –&gt; 面试题"></a>行缓冲和全缓冲(fflush) –&gt; 面试题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    printf(&quot;BEGIN&quot;);  </span><br><span class="line">    </span><br><span class="line">    //fflush(stdout);  --&gt; 注释后 printf(&quot;BEGIN&quot;); 打印了两遍</span><br><span class="line">    pid = fork();</span><br><span class="line">    if(pid &lt; 0)</span><br><span class="line">        return -1; </span><br><span class="line"></span><br><span class="line">    if(pid == 0) //子</span><br><span class="line">        printf(&quot;[%d]: child\n&quot;, getpid());</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;[%d]: parent\n&quot;, getpid());</span><br><span class="line"></span><br><span class="line">    printf(&quot;END&quot;);</span><br><span class="line">    wait();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">执行 结果，BEGIN 打印两次 END 打印两次</span><br><span class="line">[para fork_fflush]$ ./fork_fflush </span><br><span class="line">BEGIN[19918]: parent</span><br><span class="line">BEGIN[19919]: child</span><br><span class="line">ENDEND[para fork_fflush]$</span><br></pre></td></tr></table></figure><p>标准I/O提供了三种类型的缓存：<br>缓存可由标准IO例程自动的刷新，或者可以调用函数fflush刷新一个流</p><h2 id="全缓存"><a href="#全缓存" class="headerlink" title="全缓存"></a>全缓存</h2><p>1)当填满标准IO缓存后才进行实际IO操作<br>2)对于驻在磁盘上的文件通常是有标准IO库实施全缓存的</p><h2 id="行缓存"><a href="#行缓存" class="headerlink" title="行缓存"></a>行缓存</h2><p>1)当在输入和输出中遇到新行符时, 标准IO库执行实际IO操作<br>2)当流涉及一个终端时(例如标准输入和标准输出), 典型地使用行缓存<br>3)标准IO库用来收集每一行的缓存的长度固定的, 只要填满了缓存, 即使没有写一个新行符, 也进行IO操作<br>4)任何时候只要通过标准输入输出库要求从一个不带缓存的流, 或者一个行缓存的流得到输入数据, 那么就会造成刷新所有行缓存输出流</p><h2 id="不带缓存"><a href="#不带缓存" class="headerlink" title="不带缓存"></a>不带缓存</h2><p>1)标准IO库不对字符进行缓存, 如果用标准IO函数写若干字符到不带缓存的流中,<br>2)则相当于用write系统调用函数将这些字符写至相关的打开文件上<br>3)标准出错流stderr通常是不带缓存的。</p><h2 id="ANSI-C要求下列缓存特征"><a href="#ANSI-C要求下列缓存特征" class="headerlink" title="ANSI C要求下列缓存特征:"></a>ANSI C要求下列缓存特征:</h2><p>1)当且仅当标准输入和标准输出并不涉及交互作用设备时，他们才是全缓存的<br>2)标准出错绝不会是全缓存的</p><h2 id="程序问题"><a href="#程序问题" class="headerlink" title="程序问题"></a>程序问题</h2><p>因为printf是标准IO函数，默认行缓冲(遇到换行符才会刷新流)<br>若没有进行缓冲区刷新(fflush), “BEGIN”在fork之前，并没有输出到标准输出,<br>在fork的时候, 会将缓冲区的内容也复制了一份，<br>等程序到了 printf(“[%d]: child\n”, getpid()) 从缓冲区将”BEGIN”和”[%d]: child\n”进行一起打印输出</p><h2 id="fflush-刷新缓存区"><a href="#fflush-刷新缓存区" class="headerlink" title="fflush 刷新缓存区"></a>fflush 刷新缓存区</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int fflush(FILE *stream);</span><br><span class="line">返回值</span><br><span class="line">Upon successful completion 0 is returned.  Otherwise, EOF is returned and  errno  is  set  to  indicate  the</span><br><span class="line">error.</span><br></pre></td></tr></table></figure><h1 id="文件描述符和FILE结构体指针转换"><a href="#文件描述符和FILE结构体指针转换" class="headerlink" title="文件描述符和FILE结构体指针转换"></a>文件描述符和FILE结构体指针转换</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">FILE *fdopen(int fd, const char *mode);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;标准IO简介&quot;&gt;&lt;a href=&quot;#标准IO简介&quot; class=&quot;headerlink&quot; title=&quot;标准IO简介&quot;&gt;&lt;/a&gt;标准IO简介&lt;/h1&gt;&lt;p&gt;1.标准I/O是ANSI C建立的一个标准I/O模型, 是一个标准函数包和stdio.h头文件中的定义, 不依赖系统内核, 所以移植性强。&lt;br&gt;2.遵循ANSI C相关标准。需要开发环境中有标准I/O库, 标准I/O就可以使用。&lt;br&gt;3.在文件IO的基础上封装文件描述符并维护了缓冲机制。&lt;br&gt;4.fopen函数 打开一个文件, 并且建立了一个流缓冲(用户空间，读写模式下建立两个缓冲区), 还创建了一个包含文件和缓冲区相关信息的FILE结构体, 从而先读写缓冲区, 必要时候再访问实际文件。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>IO相关函数 func_io</title>
    <link href="http://www.paragarden,cn/2020/09/30/func-io/"/>
    <id>http://www.paragarden,cn/2020/09/30/func-io/</id>
    <published>2020-09-30T06:51:53.000Z</published>
    <updated>2020-10-12T02:52:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标准IO和系统IO的效率"><a href="#标准IO和系统IO的效率" class="headerlink" title="标准IO和系统IO的效率"></a>标准IO和系统IO的效率</h1><p>1.本文所讲的系统IO为 UNIX环境下的系统IO函数<br>2.标准IO 创建了一个缓冲区，当刷新缓冲区的后，在调用系统IO进行IO操作。<br>3.标准IO兼容了各种版本的系统IO<br>4.标准IO的 缓冲区(行缓冲、全缓冲，不带缓冲)<br>5.当且仅当标准输入和标准输出并不涉及交互作用设备时，他们才是全缓冲</p><a id="more"></a><h1 id="系统调用函数"><a href="#系统调用函数" class="headerlink" title="系统调用函数"></a>系统调用函数</h1><p>–&gt;open,close,lseek,read,write</p><h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int open(const char *pathname, int flags);</span><br><span class="line">int open(const char *pathname, int flags, mode_t mode);</span><br><span class="line"></span><br><span class="line">头文件：</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">const char *pathname  要打开或创建的文件的名字</span><br><span class="line">int flags</span><br><span class="line">    O_RDONLY 只读</span><br><span class="line">    O_WRONLY 只写</span><br><span class="line">    O_RDWR 可读可写</span><br><span class="line">可选</span><br><span class="line">    O_APPEND  每次写时都加到文件的尾端</span><br><span class="line">    O_CREAT    如此文件不存在则创建它，需与第三参数mode,说明新文件的存取全蝎</span><br><span class="line">        umask --&gt; ~umask | mode --&gt;权限</span><br><span class="line">    O_EXCL  如果同时指定了O_CREAT, 而文件已经存在，则报错，可测试一个文件是否存在，</span><br><span class="line">            如果不存在则创建此文件成文一个原子操作</span><br><span class="line">    O_TRUNC 如果文件存在，而且为只读或只写成功打开，则将其长度截短为0</span><br><span class="line">    O_NOCTTY 如果pathname指的是终端设备，则不将此设备分配为此进程的控制终端</span><br><span class="line">    O_NONBLOCK 如果pathname指的是一个FIFO、一个块特殊文件或一个字符特殊文件，则此选项为此</span><br><span class="line">            文件的本次打开操作和后续的I/O操作设置非阻塞方式</span><br><span class="line"></span><br><span class="line">返回值</span><br></pre></td></tr></table></figure><p>fopen 和 open 对比</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FILE *fopen(const char *path, const char *mode);</span><br><span class="line">int open(const char *pathname, int flags);</span><br><span class="line">r    只读 | 文件首                                        --&gt;O_RDONLY  </span><br><span class="line">r+   读写 | 文件首                                        --&gt;O_RDWR</span><br><span class="line">w    有则清空，无则创建 | 只写 | 文件首                     --&gt;O_WRONLY | O_CREAT | O_TRUNC</span><br><span class="line">w+   读写 有则清空，无则创建 | 文件首                       --&gt;O_RDWR | O_CREAT | O_TRUNC</span><br><span class="line">a    有则清空，无则创建 | 追加 | 读写 | 写在文件尾           --&gt;O_RDWR | O_CREAT | O_TRUNC | O_APPEND</span><br><span class="line">a+   读写  有则清空，无则创建 读在文件头、写在文件尾          --&gt;O_RDWR | O_CREAT | O_TRUNC</span><br></pre></td></tr></table></figure><h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int close(int fd);</span><br></pre></td></tr></table></figure><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">On success, the number of bytes read is returned (zero indicates end of file), and the file position is  advanced  by this  number.</span><br></pre></td></tr></table></figure><h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">On success, the number of bytes written is returned (zero indicates nothing was written).  On error, -1 is returned, and errno is set appropriately.</span><br></pre></td></tr></table></figure><h2 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">off_t lseek(int fd, off_t offset, int whence);</span><br><span class="line">参数：</span><br><span class="line">int whence SEEK_SET | SEEK_CUR | SEEK_END</span><br><span class="line">返回值：</span><br><span class="line">returns the resulting offset location as measured in bytes from the beginning of the file.  On error, the  value  (off_t) -1  is  returned  and errno is set to indicate the error.</span><br></pre></td></tr></table></figure><h1 id="标准IO操作函数"><a href="#标准IO操作函数" class="headerlink" title="标准IO操作函数"></a>标准IO操作函数</h1><p>–&gt; fopen、fclose、<br>–&gt; getc、putc、fgetc、fputc、getchar<br>–&gt; gets、puts、fgets、fputs<br>–&gt;fread、fwrite<br>–&gt; ftell、fseek、rewind</p><h2 id="fopen-、fclose"><a href="#fopen-、fclose" class="headerlink" title="fopen 、fclose"></a>fopen 、fclose</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">FILE *fopen(const char *path, const char *mode);</span><br><span class="line">r    只读 | 文件首</span><br><span class="line">r+   读写 | 文件首</span><br><span class="line">w    有则清空，无则创建 | 只写 | 文件首</span><br><span class="line">w+   读写 有则清空，无则创建 | 文件首</span><br><span class="line">a    有则清空，无则创建 | 追加 | 读写 | 写在文件尾</span><br><span class="line">a+   读写  有则清空，无则创建 读在文件头、写在文件尾</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int fclose(FILE *fp);</span><br></pre></td></tr></table></figure><h2 id="fgetc、getc、getchar、fputc、putc、putchar"><a href="#fgetc、getc、getchar、fputc、putc、putchar" class="headerlink" title="fgetc、getc、getchar、fputc、putc、putchar"></a>fgetc、getc、getchar、fputc、putc、putchar</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int fgetc(FILE *stream);</span><br><span class="line">int getc(FILE *stream);</span><br><span class="line">int getchar(void);   ---&gt; equivalent to getc(stdin)</span><br><span class="line">getc 与 fgetc 区别</span><br><span class="line">getc 宏定义  --&gt; _IO_getc</span><br><span class="line">返回值 return the character read as an unsigned char cast to an int or EOF on end of file or error.</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">int fputc(int c, FILE *stream);</span><br><span class="line">int putc(int c, FILE *stream);</span><br><span class="line">int putchar(int c);</span><br><span class="line">返回值 return the character written as an unsigned char cast to an int or EOF on error.</span><br></pre></td></tr></table></figure><h2 id="fgets、gets、-fput、puts"><a href="#fgets、gets、-fput、puts" class="headerlink" title="fgets、gets、 fput、puts"></a>fgets、gets、 fput、puts</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">char *fgets(char *s, int size, FILE *stream);  读取size-1大小的字符长度 第size 用&apos;\0&apos;补充</span><br><span class="line">char *gets(char *s);  有漏洞，慎用</span><br><span class="line">返回值 return s on success, and NULL on error or when end of file occurs while no characters have been read.</span><br><span class="line">-------------------------------------------</span><br><span class="line">int fputs(const char *s, FILE *stream);  writes the string s to stream, without its terminating null byte (&apos;\0&apos;).将字符串的&apos;\0&apos;去掉输出</span><br><span class="line">int puts(const char *s);  writes the string s and a trailing newline to stdout.</span><br><span class="line">返回值 return a nonnegative number on success, or EOF on error</span><br></pre></td></tr></table></figure><h2 id="fread、fwrite"><a href="#fread、fwrite" class="headerlink" title="fread、fwrite"></a>fread、fwrite</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</span><br><span class="line">size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);</span><br><span class="line">返回值 返回读取的次数</span><br><span class="line">return the number of items successfully read or written</span><br><span class="line">If an error occurs, or the end-of-file is reached, the return value is  a  short  item  count</span><br></pre></td></tr></table></figure><h2 id="ftell、fseek、rewind"><a href="#ftell、fseek、rewind" class="headerlink" title="ftell、fseek、rewind"></a>ftell、fseek、rewind</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int fseek(FILE *stream, long offset, int whence);  移动位置</span><br><span class="line">long ftell(FILE *stream);    返回文件指针位置</span><br><span class="line">void rewind(FILE *stream);   equivalent (void) fseek(stream, 0L, SEEK_SET)</span><br></pre></td></tr></table></figure><h2 id="fseeko、ftello"><a href="#fseeko、ftello" class="headerlink" title="fseeko、ftello"></a>fseeko、ftello</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int fseeko(FILE *stream, off_t offset, int whence); 移动位置</span><br><span class="line">off_t ftello(FILE *stream); 返回文件指针位置</span><br><span class="line"></span><br><span class="line">On many architectures both off_t and long are 32-bit types, but compilation with</span><br><span class="line">#define _FILE_OFFSET_BITS 64</span><br><span class="line">makefile:</span><br><span class="line">CFLAGS+=-D_FILE_OFFSET_BITS=64</span><br><span class="line"></span><br><span class="line">CONFORMING TO</span><br><span class="line">       SUSv2, POSIX.1-2001.</span><br><span class="line"></span><br><span class="line">fseek(stream,0,SEEK_END);</span><br></pre></td></tr></table></figure><h1 id="附加函数"><a href="#附加函数" class="headerlink" title="附加函数"></a>附加函数</h1><h2 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">ssize_t getline(char **lineptr, size_t *n, FILE *stream);</span><br><span class="line">makefile</span><br><span class="line">CFLAGS+=-D_GNU_SOURCE</span><br></pre></td></tr></table></figure><h2 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">char *tmpnam(char *s);</span><br><span class="line">FILE *tmpfile(void);</span><br></pre></td></tr></table></figure><h2 id="fflush"><a href="#fflush" class="headerlink" title="fflush"></a>fflush</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int fflush(FILE *stream);</span><br><span class="line">返回值</span><br><span class="line">Upon successful completion 0 is returned.  Otherwise, EOF is returned and  errno  is  set  to  indicate  the</span><br><span class="line">error.</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;标准IO和系统IO的效率&quot;&gt;&lt;a href=&quot;#标准IO和系统IO的效率&quot; class=&quot;headerlink&quot; title=&quot;标准IO和系统IO的效率&quot;&gt;&lt;/a&gt;标准IO和系统IO的效率&lt;/h1&gt;&lt;p&gt;1.本文所讲的系统IO为 UNIX环境下的系统IO函数&lt;br&gt;2.标准IO 创建了一个缓冲区，当刷新缓冲区的后，在调用系统IO进行IO操作。&lt;br&gt;3.标准IO兼容了各种版本的系统IO&lt;br&gt;4.标准IO的 缓冲区(行缓冲、全缓冲，不带缓冲)&lt;br&gt;5.当且仅当标准输入和标准输出并不涉及交互作用设备时，他们才是全缓冲&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>fileno</title>
    <link href="http://www.paragarden,cn/2020/09/24/fileno/"/>
    <id>http://www.paragarden,cn/2020/09/24/fileno/</id>
    <published>2020-09-24T11:33:36.000Z</published>
    <updated>2020-09-24T12:08:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h1><h2 id="文件描述符的描述"><a href="#文件描述符的描述" class="headerlink" title="文件描述符的描述"></a>文件描述符的描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a  file descriptor, a small, nonnegative integer for use in </span><br><span class="line">subsequent system calls (read(2), write(2), lseek(2), fcntl(2), etc.)  </span><br><span class="line"></span><br><span class="line"> --from man 2.6.3</span><br></pre></td></tr></table></figure><p>关键词:<br>nonnegative integer  非负整数<br>use in system calls     系统调用使用</p><p>当打开或者创建一个新的文件时，内核向进程返回一个文件描述符<br>用此文件描述符就能读写文件<br>linux一切皆文件，拿到文件描述符，就拿到了linux的钥匙</p><a id="more"></a><h2 id="标准文件描述符"><a href="#标准文件描述符" class="headerlink" title="标准文件描述符"></a>标准文件描述符</h2><p>标准输出文件描述符、标准输入文件描述符、标准错误文件描述符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* Standard file descriptors.  */</span><br><span class="line">#define STDIN_FILENO    0       /* Standard input.  */</span><br><span class="line">#define STDOUT_FILENO   1       /* Standard output.  */</span><br><span class="line">#define STDERR_FILENO   2       /* Standard error output.  */</span><br><span class="line"></span><br><span class="line">---from &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure><h2 id="文件描述符的限制"><a href="#文件描述符的限制" class="headerlink" title="文件描述符的限制"></a>文件描述符的限制</h2><p>使用ulimit -n 进行文件描述符设置当前进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[para ~]$ ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 7271</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 65535           --&gt; 文件描述符限制 65535个</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 4096</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure><p>设置永久生效最大文件描述符限制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">修改 /etc/security/limits.conf</span><br><span class="line"></span><br><span class="line">#End of file</span><br><span class="line">root soft nofile 65535</span><br><span class="line">root hard nofile 65535</span><br><span class="line">para soft nofile 1024</span><br><span class="line">para hard nofile 1024</span><br><span class="line">* soft nofile 65535</span><br><span class="line">* hard nofile 65535</span><br><span class="line"></span><br><span class="line">[para ~]$ ulimit -n</span><br><span class="line">1024</span><br></pre></td></tr></table></figure><h2 id="文件描述符唯一性"><a href="#文件描述符唯一性" class="headerlink" title="文件描述符唯一性"></a>文件描述符唯一性</h2><p>进程PCB中维护一个文件描述符表，该表的索引值从0开始<br>每个进程都有自己的PCB块，当然也有属于自己的文件描述符表<br><img src="/images/fileno/fileno0.png" alt="Alt text"></p><p>此图由unix环境高级编程书籍而来，网上说  linux系统只使用i节点，而不使用v节点 ，知道方法再细研究此问题。</p><p>(1)进程拿到文件描述符fd –&gt; 通过文件描述符表拿到对应文件描述符指针<br>(2)通过指针找到文件表的偏移量，再通过文件偏移找到当前文件指针的位置<br>(3)在通过i节点信息去文件系统进行具体操作</p><h2 id="进程结构图"><a href="#进程结构图" class="headerlink" title="进程结构图"></a>进程结构图</h2><p><img src="/images/fileno/fileno1.png" alt="Lena"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;文件描述符&quot;&gt;&lt;a href=&quot;#文件描述符&quot; class=&quot;headerlink&quot; title=&quot;文件描述符&quot;&gt;&lt;/a&gt;文件描述符&lt;/h1&gt;&lt;h2 id=&quot;文件描述符的描述&quot;&gt;&lt;a href=&quot;#文件描述符的描述&quot; class=&quot;headerlink&quot; title=&quot;文件描述符的描述&quot;&gt;&lt;/a&gt;文件描述符的描述&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a  file descriptor, a small, nonnegative integer for use in &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;subsequent system calls (read(2), write(2), lseek(2), fcntl(2), etc.)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; --from man 2.6.3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;关键词:&lt;br&gt;nonnegative integer  非负整数&lt;br&gt;use in system calls     系统调用使用&lt;/p&gt;
&lt;p&gt;当打开或者创建一个新的文件时，内核向进程返回一个文件描述符&lt;br&gt;用此文件描述符就能读写文件&lt;br&gt;linux一切皆文件，拿到文件描述符，就拿到了linux的钥匙&lt;/p&gt;</summary>
    
    
    
    
    <category term="fileno" scheme="http://www.paragarden,cn/tags/fileno/"/>
    
  </entry>
  
  <entry>
    <title>weekend</title>
    <link href="http://www.paragarden,cn/2020/09/13/weekend/"/>
    <id>http://www.paragarden,cn/2020/09/13/weekend/</id>
    <published>2020-09-13T14:41:07.000Z</published>
    <updated>2020-09-13T14:47:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Begin"><a href="#Begin" class="headerlink" title="Begin"></a>Begin</h1><p>看了部老片 “心灵捕手”，电影有几个场景有种让我想写点文字的冲动，故事很细腻，<br>每一段对话触及心灵，恰到好处，当然情节和对话的深度也是按剧情推进。</p><a id="more"></a><h1 id="One"><a href="#One" class="headerlink" title="One"></a>One</h1><p>我把电影称为 青年成长类吧，年少时也会自以为是，目视一切为空；年少时将自己包裹，<br>因为裸露内心会受伤；年少时不知自己想做什么，何为热爱，何为想要。这些都是少年的烦恼。<br>只是电影里，男主对这些问题描述的更加突出，渲染。拥有极高的天赋，目视一切；<br>寄养童年让他，防御式避开对自己内心。</p><p><img src="/images/Snipaste_2020-09-13_20-58-39.png" alt="Lena"></p><p>这里是很长一段长镜头教育，触动我的应该是老头的文字与语言魅力，<br>年少的我也是如此吧，或者道听途说，或者书上记录，款款而谈。<br>我们自以为都懂，而当时过境迁，我们再回想已是另一种滋味，是带上自己情感烙印的答案了。</p><p><img src="/images/Snipaste_2020-09-13_21-01-49.png" alt="Lena"></p><p><img src="/images/Snipaste_2020-09-13_21-04-19.png" alt="Lena"></p><h1 id="Two"><a href="#Two" class="headerlink" title="Two"></a>Two</h1><p>这一段场景，两个人坐在岸边，蓝天绿柳，很平静的阐述，很平静的述说，<br>想是在教育，有想是老头在对年轻的自己述说。如果这个场景仅仅是语言上对我的触动。<br>那接下来电影的故事，更是心灵上的触动。</p><p><img src="/images/Snipaste_2020-09-13_21-09-48.png" alt="Lena"></p><p><img src="/images/Snipaste_2020-09-13_21-11-56.png" alt="Lena"></p><p>我们之间就是这样，老想将自己最完美，最优秀的自己展示给对方。<br>其实我们自己都知道，自己不完美，甚至自卑，但是总想在对方的心里保持完美的形象。<br>这就是你说的摸不到对方的心。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>电影是好电影，教育意义。那防御式的青年，就是那个自己。从没有把自己的内心拿出来过，藏在心底，甚至不知道和谁谈述。<br>终于当你找到一个自己的心灵伴侣，慢慢的会将自己的情感去向她表达，决定将自己的真心交给她。</p><p>没关系，明天又是假装的自己，用表情来掩盖自己，将真心埋葬了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Begin&quot;&gt;&lt;a href=&quot;#Begin&quot; class=&quot;headerlink&quot; title=&quot;Begin&quot;&gt;&lt;/a&gt;Begin&lt;/h1&gt;&lt;p&gt;看了部老片 “心灵捕手”，电影有几个场景有种让我想写点文字的冲动，故事很细腻，&lt;br&gt;每一段对话触及心灵，恰到好处，当然情节和对话的深度也是按剧情推进。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>初识ssh</title>
    <link href="http://www.paragarden,cn/2020/09/09/ssh01/"/>
    <id>http://www.paragarden,cn/2020/09/09/ssh01/</id>
    <published>2020-09-09T02:52:02.000Z</published>
    <updated>2020-10-12T07:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>ssh前言<br>最近在写自动化脚本，需要登录多台服务器操作。由于频繁输入密码，进行配置免密登录(公钥登录)，在此记录细节。</p><p>ssh只是一种计算机之间机密登录的协议，它相对于telnet和rsh的明文传输，<br>提供了加密、校验和压缩，使得我们可以很安全的远程操作，<br>而不用担心信息泄露(当然不是绝对的，加密总有可能被破解，只是比起明文来说那是强了不少)。</p><a id="more"></a><h1 id="ssh基本用法"><a href="#ssh基本用法" class="headerlink" title="ssh基本用法"></a>ssh基本用法</h1><p>远程登录主机host</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh user@host</span><br></pre></td></tr></table></figure><p>如果本地用户名与远程用户名一致，登录时可以省略用户名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh host</span><br></pre></td></tr></table></figure><p>ssh的默认端口22，使用p参数修改端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -p 2222 user@host</span><br></pre></td></tr></table></figure><h1 id="加密简介"><a href="#加密简介" class="headerlink" title="加密简介"></a>加密简介</h1><p>加密的意思是将一段数据经过处理之后，输出为一段外人无法或者很难破译的数据，除了指定的人可以解密之外。<br>一般来说，加密的输入还会有一个key，这个key作为加密的参数，而在解密的时候也会用一个相关联(有可能是相同)的key作为输入。<br>粗略来说是下面的流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 加密方</span><br><span class="line">encrypted_data = encrypt(raw_data, key)</span><br><span class="line"># 解密方</span><br><span class="line">raw_data = decrypt(encrypted_data, key1)</span><br></pre></td></tr></table></figure><p>目前主流的加密算法一般分为下面两类：<br>私钥(secret key)加密，也称为对称加密<br>公钥(public key)加密，也称非对称加密</p><h2 id="私钥加密"><a href="#私钥加密" class="headerlink" title="私钥加密"></a>私钥加密</h2><p>私钥加密，加密方和解密方用的是同一个key，这个key对于加密和解密双方来说都是保密的。<br>一般来说是加密方先产生私钥，然后通过一个安全的途径来告知解密方这个私钥。</p><h2 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h2><p>公钥加密，解密方生成一对密钥(公钥和私钥)，公钥对外发布，私钥自己保存。用公钥加密的数据，只能私钥进行解密。<br>加密方首先需要获取到公钥，然后利用这个公钥进行加密，把数据发送给解密方，解密方用私钥进行解密获取数据。<br>如果解密的数据在传输的过程中被第三方截获，也不用担心，因为第三方没有私钥，没有办法进行解密。</p><p><img src="/images/ssh02.png" alt="Lena"></p><p>但是公钥加密还是会有风险，有人冒充解密方发送一对伪造的密钥，那么他就能解出加密方所上送的数据。<br>那么加密方很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。<br>这种封建就是著名的”中间人攻击”(Man-in-the-middle attack)。所以公钥加密里面比较重要的一步是身份认证。</p><p><img src="/images/ssh03.png" alt="Lena"></p><p>一般的私钥加密都会比公钥加密快，所以大数据量的加密一般都会使用私钥加密，而公钥加密会作为身份验证和交换私钥的一个手段。</p><h2 id="身份校验"><a href="#身份校验" class="headerlink" title="身份校验"></a>身份校验</h2><p>上面讲到公钥加密的风险，那么ssh协议是如何应对的呢？</p><p>如果你是第一次登陆对方主机，系统会出现下面提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[para@para2 ~]$ ssh para@47.114.0.16</span><br><span class="line">The authenticity of host &apos;47.114.0.16 (47.114.0.16)&apos; can&apos;t be established.</span><br><span class="line">ECDSA key fingerprint is da:eb:96:f4:79:05:fb:3a:2a:34:4f:04:c1:a6:29:39.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>这代表，无法确认host主机的真实性，只有他的公钥指纹(ECDSA key fingerprint)，问还想继续连接吗</p><p>“公钥指纹”，公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。<br>上例中是da:eb:96:f4:79:05:fb:3a:2a:34:4f:04:c1:a6:29:39，再进行比较，就容易多了。<br>然而远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。</p><p>用户决定接受这个远程主机的公钥。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br></pre></td></tr></table></figure><p>系统会提示host主机已经得到认可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added &apos;47.114.0.16&apos; (ECDSA) to the list of known hosts.</span><br><span class="line">para@47.114.0.16&apos;s password:</span><br></pre></td></tr></table></figure><p>如果密码正确，就可以登录了。</p><p>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。<br>下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。</p><p>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，<br>保存一些对所有用户都可信赖的远程主机的公钥。</p><h2 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h2><p>数据一致性说得是如何保证一段数据在传输的过程中没有遗漏、破坏或者修改过。一般来说，目前流行的做法是对数据进行hash，<br>得到的hash值和数据一起传输，然后在收到数据的时候也对数据进行hash，将得到的hash值和传输过来的hash值进行比对，<br>如果是不一样的，说明数据已经被修改过；如果是一样的，则说明极有可能是完整的。</p><p>目前流行的hash算法有MD5和SHA-1算法。</p><h1 id="ssh连接过程"><a href="#ssh连接过程" class="headerlink" title="ssh连接过程"></a>ssh连接过程</h1><h2 id="口令登录"><a href="#口令登录" class="headerlink" title="口令登录"></a>口令登录</h2><p>(1)身份校验：用户同意后进行登录操作<br>(2)远程主机收到用户的登录请求，把自己的公钥发给用户。<br>(3)用户使用这个公钥，将登录密码加密后，发送回来。<br>(4)远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</p><h2 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h2><p>口令登录每次都要输入密码，非常麻烦，ssh提供了公钥登录，省去了输入密码的步骤</p><p>公钥登录原理，用户将自己的公钥存在远程主机上。登录的时候，远程主机会向用户发送<br>一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先存储的公钥进行解密，<br>解密成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</p><p><img src="/images/ssh01.png" alt="Lena"></p><p>操作步骤：<br>1.ssh-keygen -t rsa 命令生成一对密钥对，放在 $HOME/.ssh/目录下，分别为id_rsa.pub和id_rsa。<br>id_rsa是私钥(保存)，id_rsa.pub是公钥(给服务器保存)</p><p>2.输入命令  ssh-copy-id user@host,将公钥发送至远程host上</p><p>3.检查远程主机的配置文件 /etc/ssh/sshd_config 是否开启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　RSAAuthentication yes</span><br><span class="line">　PubkeyAuthentication yes</span><br><span class="line">　AuthorizedKeysFile .ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>修改后重启ssh服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu系统 service ssh restart </span><br><span class="line">debian系统 /etc/init.d/ssh restart</span><br></pre></td></tr></table></figure><p>4.修改远程主机配置文件<br>chmod 600 $HOME/.ssh/authorized_keys<br>chmod 700 $HOME/.ssh/</p><h1 id="authorized-keys和known-hosts文件"><a href="#authorized-keys和known-hosts文件" class="headerlink" title="authorized_keys和known_hosts文件"></a>authorized_keys和known_hosts文件</h1><p>当新连接一台远程主机，都会进行身份校验，公钥指纹保存在$HOME/.ssh/known_hosts文件中。<br>远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。</p><p>因此可以直接将客户端的公钥追加到远程主机的authorized_keys文件中<br>命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　$ ssh user@host &apos;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&apos; &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;ssh前言&lt;br&gt;最近在写自动化脚本，需要登录多台服务器操作。由于频繁输入密码，进行配置免密登录(公钥登录)，在此记录细节。&lt;/p&gt;
&lt;p&gt;ssh只是一种计算机之间机密登录的协议，它相对于telnet和rsh的明文传输，&lt;br&gt;提供了加密、校验和压缩，使得我们可以很安全的远程操作，&lt;br&gt;而不用担心信息泄露(当然不是绝对的，加密总有可能被破解，只是比起明文来说那是强了不少)。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hexo create</title>
    <link href="http://www.paragarden,cn/2019/10/06/T1006/"/>
    <id>http://www.paragarden,cn/2019/10/06/T1006/</id>
    <published>2019-10-06T11:23:01.000Z</published>
    <updated>2019-10-06T11:34:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-create"><a href="#Hexo-create" class="headerlink" title="Hexo create"></a>Hexo create</h1><p>Hexo搭建了很多次，由于是在虚拟机中搭建的<br>由于经常换虚拟机，每次更换搭建的hexo都没有了<br>heox的环境搭建也较麻烦，在此记录</p><a id="more"></a><h2 id="1-安装git工具"><a href="#1-安装git工具" class="headerlink" title="1.安装git工具"></a>1.安装git工具</h2><p>sudo yum -y install git-all.noarch</p><h2 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2.安装Node.js"></a>2.安装Node.js</h2><p>curl -o- <a href="https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh" target="_blank" rel="noopener">https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh</a> | bash<br>nvm install node</p><h2 id="3-安装-Hexo"><a href="#3-安装-Hexo" class="headerlink" title="3.安装 Hexo"></a>3.安装 Hexo</h2><p>npm install -g hexo-cli<br>npm install hexo<br>3.1设置hexo环境变量<br>echo ‘PATH=”$PATH:./node_modules/.bin”‘ &gt;&gt; ~/.profile</p><h2 id="4-建站"><a href="#4-建站" class="headerlink" title="4.建站"></a>4.建站</h2><p>hexo init</p><h3 id="4-1-Next-主题"><a href="#4-1-Next-主题" class="headerlink" title="4.1 Next 主题"></a>4.1 Next 主题</h3><p>mkdir themes/next<br>curl -L <a href="https://api.github.com/repos/iissnan/hexo-theme-next/tarball/v5.1.2" target="_blank" rel="noopener">https://api.github.com/repos/iissnan/hexo-theme-next/tarball/v5.1.2</a> | tar -zxv -C themes/next –strip-components=1</p><h3 id="4-2安装本地服务器"><a href="#4-2安装本地服务器" class="headerlink" title="4.2安装本地服务器"></a>4.2安装本地服务器</h3><p>npm install hexo-server –save</p><h2 id="5-hexo和github联系起来"><a href="#5-hexo和github联系起来" class="headerlink" title="5.hexo和github联系起来"></a>5.hexo和github联系起来</h2><h3 id="5-1安装git插件"><a href="#5-1安装git插件" class="headerlink" title="5.1安装git插件"></a>5.1安装git插件</h3><p>npm install hexo-deployer-git –save</p><h3 id="5-2本地添加公钥参考git-syn"><a href="#5-2本地添加公钥参考git-syn" class="headerlink" title="5.2本地添加公钥参考git.syn"></a>5.2本地添加公钥参考git.syn</h3><h3 id="5-3配置Deployment-在-config-yml文件，修改repo值"><a href="#5-3配置Deployment-在-config-yml文件，修改repo值" class="headerlink" title="5.3配置Deployment 在_config.yml文件，修改repo值"></a>5.3配置Deployment 在_config.yml文件，修改repo值</h3><p>deploy:<br>    type: git<br>    repository: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:padparadccha/padparadccha.github.io.git<br>    branch: master</p><h2 id="6-部署发布"><a href="#6-部署发布" class="headerlink" title="6.部署发布"></a>6.部署发布</h2><p>hexo d -g</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Hexo-create&quot;&gt;&lt;a href=&quot;#Hexo-create&quot; class=&quot;headerlink&quot; title=&quot;Hexo create&quot;&gt;&lt;/a&gt;Hexo create&lt;/h1&gt;&lt;p&gt;Hexo搭建了很多次，由于是在虚拟机中搭建的&lt;br&gt;由于经常换虚拟机，每次更换搭建的hexo都没有了&lt;br&gt;heox的环境搭建也较麻烦，在此记录&lt;/p&gt;</summary>
    
    
    
    
    <category term="Technology" scheme="http://www.paragarden,cn/tags/Technology/"/>
    
  </entry>
  
  <entry>
    <title>记录下第一封信</title>
    <link href="http://www.paragarden,cn/2019/09/09/909/"/>
    <id>http://www.paragarden,cn/2019/09/09/909/</id>
    <published>2019-09-09T06:02:31.000Z</published>
    <updated>2019-10-06T11:34:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天早上，我看到你发的日记了。。。<br>我哭了，因为你的感受和我的一样，你写的我都感受的到。<br>你总是在我脑海里，随时都可能会出现，<br>不经意间的出现，我就呆呆的在那思索片刻，又继续工作。</p><a id="more"></a><p>我总是在想，我是个渣男<br>没有能力承担这责任，也不知道该如何解决。<br>我就不该去找你，而找你之后，我却狠心离开。<br>我常常在想分开那晚，你说的话：<br>你不想挂断，因为你知道，这已挂断就不会再有联系了。<br>我像个骗子一样，不停的安慰你：<br>没事的，就当今晚什么都没有发生，我们第二天仍然像以前一样。<br>过了多少个第二天，确实没有再联系了。<br>我真是个骗子。</p><p>我进退两难，<br>不知道该去找你，还是继续克制自己。<br>以前我一直抓住不放手，是因为我觉得，我还有机会改变我们以后，<br>现在，我对自己无力了，时间飞逝，以来不及我去做准备，<br>毕业三年来，还是原来的我，没有任何能力去改变，<br>我终究没有能力，<br>我一直以为，我会成长到去拥有你的能力，<br>才发现，时间已过，我还在原地<br>我真不想浪费你的时间了</p><p>愿， 你， 幸福</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天早上，我看到你发的日记了。。。&lt;br&gt;我哭了，因为你的感受和我的一样，你写的我都感受的到。&lt;br&gt;你总是在我脑海里，随时都可能会出现，&lt;br&gt;不经意间的出现，我就呆呆的在那思索片刻，又继续工作。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
